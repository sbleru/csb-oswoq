{"version":3,"sources":["index.js"],"names":["Fatline","curve","width","color","speed","opacity","material","useRef","useFrame","current","uniforms","dashOffset","value","attach","vertices","ref","transparent","depthTest","lineWidth","dashArray","dashRatio","Lines","count","colors","edgeCount","Math","cbrt","useMemo","z","y","x","Array","keys","map","i","pos","THREE","random","points","num","clone","add","sp","splice","floor","length","renderPoints","concat","getPoints","parseInt","max","props","index","App","linear","camera","position","fov","focusDistance","focalLength","bokehScale","height","luminanceThreshold","luminanceSmoothing","extend","meshline","render","document","querySelector"],"mappings":"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","file":"static/js/main.faec8e2c.chunk.js","sourcesContent":["import { render } from 'react-dom'\nimport React, { useMemo, useRef } from 'react'\nimport * as THREE from 'three'\nimport * as meshline from 'threejs-meshline'\nimport { extend, Canvas, useFrame, useThree } from '@react-three/fiber'\nimport './styles.css'\nimport { OrbitControls } from '@react-three/drei'\nimport { EffectComposer, DepthOfField, Bloom, Noise, Vignette } from '@react-three/postprocessing'\n\nextend(meshline)\n\nfunction Fatline({ curve, width, color, speed, opacity }) {\n  const material = useRef()\n  useFrame(() => (material.current.uniforms.dashOffset.value -= speed))\n  return (\n    <mesh>\n      <meshLine attach=\"geometry\" vertices={curve} />\n      <meshLineMaterial\n        attach=\"material\"\n        ref={material}\n        transparent\n        depthTest={false}\n        lineWidth={width}\n        color={color}\n        dashArray={1}\n        dashRatio={0.1}\n        opacity={opacity}\n      />\n    </mesh>\n  )\n}\n\n// TODO\n//\nfunction Lines({ count, colors }) {\n  const boxOffset = 10\n  const edgeCount = Math.cbrt(count)\n  const lines = useMemo(() => {\n    let z = 0\n    let y = 0\n    let x = 0\n    return [...Array(count).keys()].map((i) => {\n      const pos = new THREE.Vector3(x * boxOffset + 2 * Math.random(), y * boxOffset + 2 * Math.random(), z * boxOffset + 2 * Math.random())\n      x++\n      if (x % edgeCount === 0) {\n        x = 0\n        y++\n      }\n      if (x % edgeCount === 0 && y % edgeCount === 0) {\n        y = 0\n        z++\n      }\n      // return yArray.map((xArray, y) => {\n      // const pos = new THREE.Vector3(10 - Math.random() * 20, 10 - Math.random() * 20, 10 - Math.random() * 20)\n      // const points = new Array(30).fill().map(() => pos.add(new THREE.Vector3(4 - Math.random() * 8, 4 - Math.random() * 8, 2 - Math.random() * 4)).clone())\n      // const pos = new THREE.Vector3(0, 0, 0)\n      const points = [...Array(9).keys()].map((num) => {\n        const baseLineRatio = 3\n        switch (num) {\n          case 0:\n            return pos.clone()\n          case 1:\n            return pos.add(new THREE.Vector3(1 * baseLineRatio, 0, 0)).clone()\n          case 2:\n            return pos.add(new THREE.Vector3(0, 0, -1 * baseLineRatio)).clone()\n          case 3:\n            return pos.add(new THREE.Vector3(-1 * baseLineRatio, 0, 0)).clone()\n          case 4:\n            return pos.add(new THREE.Vector3(0, -1 * baseLineRatio, 0)).clone()\n          case 5:\n            return pos.add(new THREE.Vector3(1 * baseLineRatio, 0, 0)).clone()\n          case 6:\n            return pos.add(new THREE.Vector3(0, 0, 1 * baseLineRatio)).clone()\n          case 7:\n            return pos.add(new THREE.Vector3(-1 * baseLineRatio, 0, 0)).clone()\n          case 8:\n            return pos.add(new THREE.Vector3(0, 1 * baseLineRatio, 0)).clone()\n          default:\n            break\n        }\n        return null\n      })\n      const sp = points.splice(0, Math.floor(Math.random() * points.length))\n      const renderPoints = points.concat(sp)\n      const curve = new THREE.CatmullRomCurve3(renderPoints).getPoints(renderPoints.length - 1)\n      return {\n        color: colors[parseInt(colors.length * Math.random())],\n        width: Math.max(0.2),\n        speed: Math.max(0.004),\n        curve\n      }\n      // })\n    })\n  }, [colors, count])\n  return lines.map((props, index) => <Fatline key={index} {...props} />)\n}\n\nfunction Rig({ mouse }) {\n  const { camera, viewport } = useThree()\n  useFrame((state) => {\n    camera.position.x += (state.mouse.x * viewport.width - camera.position.x) * 0.05\n    camera.position.y += (-state.mouse.y * viewport.height - camera.position.y) * 0.05\n    camera.lookAt(0, 0, 0)\n  })\n  return null\n}\n\nfunction App() {\n  const colors = ['#FFFFFF']\n  // const colors = ['#A2CCB6', '#FCEEB5', '#EE786E', '#e0feff', 'lightpink', 'lightblue'];\n  return (\n    <Canvas linear camera={{ position: [30, 30, 50], fov: 25 }}>\n      <Lines count={1000} colors={colors} />\n      {/* <Rig /> */}\n      <OrbitControls />\n      <EffectComposer>\n        <DepthOfField focusDistance={0} focalLength={0.02} bokehScale={2} height={480} />\n        <Bloom luminanceThreshold={0} luminanceSmoothing={0.9} height={300} />\n        <Noise opacity={0.02} />\n        {/* <Vignette eskil={false} offset={0.1} darkness={1.1} /> */}\n      </EffectComposer>\n    </Canvas>\n  )\n}\n\nrender(<App />, document.querySelector('#root'))\n"],"sourceRoot":""}